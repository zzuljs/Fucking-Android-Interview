# 弱网定义  

## 网络性能指标：

**网速**：指传送数据的速率。速率是计算机网络中最重要的性能指标，单位是b/s(比特每秒，也写作bps ，即bit per second )

**请求成功率**：即一段时间内网络接口请求成功率

**带宽**：带宽用来表示网络的通信线路传送数据的能力，表示在单位时间内从网络中的某一点到另一点所能通过的“最高速率”。

**吞吐量（throughput）**：表示在单位时间内通过某网络的数据量。吞吐量常用于对网络的一种测量。吞吐量受网络带宽或者速率限制

**往返时间RTT（Round-Trip Time）**：表示从发送方发送数据开始，到发送方收到接收方的确认，总共经历的时间

**HttpRTT**：指从客户端请求的第一个字节开始发送到收到第一个数据包响应的时间差。这个时间包含3个部分，客户端发送数据到服务器耗时、服务器处理耗时、服务器响应数据到客户端耗时

## 弱网诊断观察的指标

弱网诊断根据HttpRTT和吞吐量来观察用户网络环境

HttpRTT：在不考虑服务器处理耗时的情况下，能够体现用户请求被处理的真实时延

吞吐量（throughput）：用户的额定速率能被系统提供的API获取到，然而其仅能表示设备能够提供的最大速率（一般很大），却不是真实速率，而测量真实的吞吐量更能体现出用户当前真实网络环境

# 现有方案

现有方案主要通过被动采集和主动探测两种方式来判断弱网，计算指标包含网速和成功率两个指标

![现有实现方案](../images/App弱网监控方案.png)

现有方案的缺陷：

1. RTT受网络波动影响较大，单次检测不准确
2. 现有方案中，弱网的定义过于静态、单一，容易出现抖动

# 改进方案

改进方案可以结合携程和得物两个方案的总结，在主动探测和被动探测基础上，增加滑动窗口、EMA权重计算、防抖策略等方式，联合多指标计算，判断网络质量，使监测结果更加精准 

## 滑动窗口：指数加权移动平均线 (EMA) 

保存最近T时间（如T=10s）内所有网络请求进行采样，计算性能指标（如HttpRTT和吞吐量），使时间窗口内采样值通过EMA加权运算，得到最终结果更加平滑

**EMA公式：**

$$
EMA_{t} = (1-\alpha) \times EMA_{t-1} + \alpha \times X_{t}
$$

**其中：**

$$
\alpha = 1 - e^{-\Delta t / \tau}
$$

- $\Delta t$：当前样本与上次样本的时间间隔
- $\tau$：时间常数（决定记忆长度）
- $EMA_{t}$: 表示加权观测值
- $ X_{t}$: 表示当前观测值
- $\alpha$: 表示平滑因子，$\alpha$ 计算公式使时间越近的观测值权重越高

## 防抖策略  

连续N个窗口计算结果一致后，才认为状态发生了变化，不要单次窗口就翻转状态，防止网络波动导致频繁触发弱网上报  

比如：需要连续 3 个窗口判断为弱网才真正切换到弱网；恢复也需要连续 3 个窗口为好网才恢复  

## 百分位统计（P90）  

在滑动窗口内，计算所有样本90分位数据，比计算平均值更能避免极端数据的干扰  

比如：一组数据包含10个样本，RTT时间分别是 10ms,10ms,10ms,10ms,10ms,10ms,10ms,10ms,10ms,1000ms  

p90 RTT是10ms，表示90%的请求≤10ms，比平均值109ms更有参考价值

## 多指标联合判断

综合考虑多个指标来判断网络质量，避免单一指标失效导致误判，在一次滑动窗口之内，计算所有样本RTT数据和吞吐量数据的EMA权值、百分位阈值

# Android端实现Demo

核心功能类：

`NetworkQualityTracker`：滑动窗口 / EMA 支持、防抖策略、计算指标、弱网判断

`NetworkMonitorInterceptor`：OkHttp 网络拦截器，记录TTFB

**核心代码逻辑**
```kotlin
// ---------- 基本类型 ----------
enum class WindowMode { COUNT, TIME, EMA }

data class Sample(
    val ts: Long = System.currentTimeMillis(),
    val success: Boolean,
    val durationMs: Long,
    val bytes: Long
)

data class Metrics(
    val avgLatencyMs: Double,
    val p50LatencyMs: Long,
    val p90LatencyMs: Long,
    val avgThroughputKbps: Double,
    val failRate: Double,
    val sampleCount: Int
)

interface NetworkQualityListener {
    fun onQualityChanged(isWeak: Boolean, metrics: Metrics)
}

// ---------- Tracker 实现 ----------
class NetworkQualityTracker(
    private val windowMode: WindowMode = WindowMode.COUNT,
    private val windowSize: Int = 50,             // 当 MODE=COUNT 时生效
    private val windowMillis: Long = 60_000L,     // 当 MODE=TIME 时生效
    private val emaAlpha: Double = 0.2,           // 当 MODE=EMA 时的 alpha
    private val latencyThresholdMs: Long = 800L,  // 判弱网阈值：延迟（ms）
    private val throughputThresholdKbps: Double = 100.0, // 判弱网阈值：吞吐 (KB/s)
    private val failRateThreshold: Double = 0.3,  // 判弱网阈值：失败率
    private val confirmCount: Int = 3             // 防抖需要连续 N 窗口
) {
    private val samples = ArrayDeque<Sample>()
    // EMA 状态
    private var emaLatency = 0.0
    private var emaThroughput = 0.0
    private var emaFail = 0.0

    private val listeners = CopyOnWriteArraySet<NetworkQualityListener>()

    @Volatile private var currentWeak: Boolean? = null
    @Volatile private var consecWeak = 0
    @Volatile private var consecGood = 0

    // 记录样本（线程安全）
    @Synchronized
    fun record(sample: Sample) {
        samples.addLast(sample)
        when (windowMode) {
            WindowMode.COUNT -> while (samples.size > windowSize) samples.removeFirst()
            WindowMode.TIME -> {
                val cutoff = System.currentTimeMillis() - windowMillis
                while (samples.isNotEmpty() && samples.first.ts < cutoff) samples.removeFirst()
            }
            WindowMode.EMA -> {
                // 对 EMA 我们依然保留一小部分样本（可选）
                while (samples.size > max(10, windowSize)) samples.removeFirst()
                // 更新 EMA 值
                val latency = sample.durationMs.toDouble()
                val throughput = if (sample.bytes > 0 && sample.durationMs > 0) (sample.bytes * 1000.0 / sample.durationMs / 1024.0) else emaThroughput
                val fail = if (sample.success) 0.0 else 1.0
                if (emaLatency == 0.0) {
                    emaLatency = latency; emaThroughput = throughput; emaFail = fail
                } else {
                    emaLatency = emaAlpha * latency + (1 - emaAlpha) * emaLatency
                    emaThroughput = emaAlpha * throughput + (1 - emaAlpha) * emaThroughput
                    emaFail = emaAlpha * fail + (1 - emaAlpha) * emaFail
                }
            }
        }

        // 记录后尝试评估并触发状态变化（带防抖）
        tryUpdateState()
    }

    // 计算当前 metrics
    @Synchronized
    fun computeMetrics(): Metrics {
        val list = samples.toList()
        if (list.isEmpty()) return Metrics(0.0, 0L, 0L, 0.0, 0.0, 0)

        val durations = list.map { it.durationMs }.sorted()
        val avgLatency = list.map { it.durationMs }.average()
        val p50 = percentile(durations, 50)
        val p90 = percentile(durations, 90)
        val throughputs = list.mapNotNull {
            if (it.bytes > 0 && it.durationMs > 0)
                it.bytes * 1000.0 / it.durationMs / 1024.0
            else null
        }
        val avgThroughput = if (throughputs.isEmpty()) 0.0 else throughputs.average()
        val failRate = list.count { !it.success }.toDouble() / list.size
        return Metrics(avgLatency, p50, p90, avgThroughput, failRate, list.size)
    }

    private fun percentile(sortedList: List<Long>, p: Int): Long {
        if (sortedList.isEmpty()) return 0L
        val n = sortedList.size
        val pos = (p / 100.0) * (n - 1)
        val lower = floor(pos).toInt()
        val upper = ceil(pos).toInt()
        if (lower == upper) return sortedList[lower]
        val lowerVal = sortedList[lower]
        val upperVal = sortedList[upper]
        val frac = pos - lower
        return (lowerVal + (upperVal - lowerVal) * frac).roundToLong()
    }

    private fun evaluate(metrics: Metrics): Boolean {
        return if (windowMode == WindowMode.EMA) {
            (emaLatency > latencyThresholdMs) || (emaThroughput < throughputThresholdKbps) || (emaFail > failRateThreshold)
        } else {
            (metrics.avgLatencyMs > latencyThresholdMs) || (metrics.avgThroughputKbps < throughputThresholdKbps) || (metrics.failRate > failRateThreshold)
        }
    }

    private fun tryUpdateState() {
        val metrics = computeMetrics()
        val weak = evaluate(metrics)

        if (weak) {
            consecWeak++; consecGood = 0
            if (consecWeak >= confirmCount && (currentWeak == null || currentWeak == false)) {
                currentWeak = true
                listeners.forEach { it.onQualityChanged(true, metrics) }
            }
        } else {
            consecGood++; consecWeak = 0
            if (consecGood >= confirmCount && (currentWeak == null || currentWeak == true)) {
                currentWeak = false
                listeners.forEach { it.onQualityChanged(false, metrics) }
            }
        }
    }

    fun isWeakNow(): Boolean = currentWeak ?: false
    fun addListener(l: NetworkQualityListener) = listeners.add(l)
    fun removeListener(l: NetworkQualityListener) = listeners.remove(l)
}

// ---------- OkHttp Interceptor（统计 TTFB & 包装 Body 以统计完整下载） ----------
class NetworkMonitorInterceptor(
    private val tracker: NetworkQualityTracker = NetworkQualityTracker()
) : Interceptor {
    override fun intercept(chain: Interceptor.Chain): Response {
        val request = chain.request()

        // 可选：允许通过 request.tag 来排除某些请求（比如大文件 / CDN / heartbeat）
        val tag = request.tag(String::class.java)
        if (tag == "NO_MONITOR") {
            return chain.proceed(request)
        }

        val startNs = System.nanoTime()
        try {
            val response = chain.proceed(request) // 在这里返回时 headers 已经返回（TTFB）
            val ttfbMs = (System.nanoTime() - startNs) / 1_000_000
            val contentLength = response.body?.contentLength() ?: -1L
            val success = response.isSuccessful

            // 先用 TTFB 作为一个轻量样本（在 APP 不一定会消费完 body 的场景很有用）
            tracker.record(Sample(System.currentTimeMillis(), success, ttfbMs, if (contentLength > 0) contentLength else -1L))

            // 如果 body 存在，返回一个包装的 ResponseBody，在真正读取完或异常时记录完整下载耗时与字节数
            val body = response.body
            if (body != null) {
                val counting = CountingResponseBody(body) { bytes, durationMs, successFull ->
                    tracker.record(Sample(System.currentTimeMillis(), successFull, durationMs, bytes))
                }
                return response.newBuilder().body(counting).build()
            }
            return response
        } catch (e: IOException) {
            val durMs = (System.nanoTime() - startNs) / 1_000_000
            tracker.record(Sample(System.currentTimeMillis(), false, durMs, -1))
            throw e
        }
    }
}

class CountingResponseBody(
    private val delegate: ResponseBody,
    private val onComplete: (bytes: Long, durationMs: Long, success: Boolean) -> Unit
) : ResponseBody() {

    override fun contentType() = delegate.contentType()
    override fun contentLength() = delegate.contentLength()

    override fun source(): BufferedSource {
        val original = delegate.source()
        val forward = object : ForwardingSource(original) {
            var total = 0L
            var startReadNano = 0L
            var completed = false

            @Throws(IOException::class)
            override fun read(sink: Buffer, byteCount: Long): Long {
                if (startReadNano == 0L) startReadNano = System.nanoTime()
                try {
                    val read = super.read(sink, byteCount)
                    if (read > 0) total += read
                    if (read == -1L && !completed) {
                        completed = true
                        val durMs = (System.nanoTime() - startReadNano) / 1_000_000
                        onComplete(total, durMs, true)
                    }
                    return read
                } catch (io: IOException) {
                    if (!completed) {
                        completed = true
                        val durMs = (System.nanoTime() - startReadNano) / 1_000_000
                        onComplete(total, durMs, false)
                    }
                    throw io
                }
            }
        }
        return forward.buffer()
    }
}


// 使用示例

val tracker = NetworkQualityTracker(
    windowMode = WindowMode.COUNT,
    windowSize = 50,
    latencyThresholdMs = 800L,
    throughputThresholdKbps = 100.0,
    failRateThreshold = 0.3,
    confirmCount = 3
)

tracker.addListener(object: NetworkQualityListener {
    override fun onQualityChanged(isWeak: Boolean, metrics: Metrics) {
        // 在这里做策略调整：降低图片质量、延后非关键请求、上报埋点等
        Log.i("NetQo", "isWeak=$isWeak metrics=$metrics")
    }
})

val client = OkHttpClient.Builder()
    .addNetworkInterceptor(NetworkMonitorInterceptor(tracker)) // network interceptor 推荐用于测真实网络
    .build()
```

github代码仓地址 ：


# 扩展：实时网络质量监控  

现有方案以被动检测为主，主动探测作为补充，缺乏实时性  

考虑引入滑动窗口轮询+主动探测补偿方案，过程如下：



# 参考文献

[1. 携程APP移动网络优化实践（弱网识别篇） ](https://cloud.tencent.com/developer/article/2465622)  
[2. 得物自研移动端弱网诊断工具的技术实践](https://tech.dewu.com/article?id=142)  
[3. 移动端弱网优化专题(一)：通俗易懂，理解移动网络的“弱”和“慢”](http://www.52im.net/thread-1587-1-1.html)   
[4. Google网络质量评估NQE核心实现代码](https://chromium.googlesource.com/chromium/src/+/HEAD/net/nqe/network_quality_estimator.cc)  