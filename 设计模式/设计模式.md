设计模式通常分为三大类：创建型、结构型和行为型。以下是23种设计模式的分类及简要概括：

# 一、创建型模式 (Creational Patterns)

这类模式主要用于对象的创建，将对象的创建与使用分离，使系统更加灵活。

1. [工厂方法模式 (Factory Method)](工厂方法.md)：定义一个创建对象的接口，让子类决定实例化哪个类。

2. [抽象工厂模式 (Abstract Factory)](抽象工厂.md)：提供一个接口，用于创建相关或依赖对象的家族，而无需指定具体类。

3. [单例模式 (Singleton)](单例.md)：确保一个类只有一个实例，并提供一个全局访问点。

4. [建造者模式 (Builder)](建造者.md)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

5. [原型模式 (Prototype)](原型.md)：用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。

# 二、结构型模式 (Structural Patterns)

这类模式关注如何将类和对象组合成更大的结构，以实现新的功能。

1. [适配器模式 (Adapter)](适配器.md)：将一个类的接口转换成客户希望的另一个接口，使原本不兼容的类可以合作。

2. [桥接模式 (Bridge)](桥接.md)：将抽象与实现分离，使它们可以独立变化。

3. [组合模式 (Composite)](组合.md)：将对象组合成树形结构以表示“部分-整体”的层次结构，使客户端对单个对象和组合对象的使用具有一致性。

4. [装饰器模式 (Decorator)](装饰器.md)：动态地给一个对象添加一些额外的职责，相比生成子类更加灵活。

5. [外观模式 (Facade)](外观.md)：为子系统中的一组接口提供一个统一的入口，定义一个高层接口，使子系统更容易使用。

6. [享元模式 (Flyweight)](享元.md)：运用共享技术有效地支持大量细粒度对象的复用。

7. [代理模式 (Proxy)](代理.md)：为另一个对象提供一个替身或占位符，以控制对这个对象的访问。

# 三、行为型模式 (Behavioral Patterns)

这类模式关注对象之间职责的分配和算法的实现，它们描述了对象如何相互协作，共同完成任务。

1. [责任链模式 (Chain of Responsibility)](责任链.md)：为解除请求的发送者和接收者之间耦合，使多个对象都有机会处理请求，将这些对象连成一条链，并沿着这条链传递请求，直到有一个对象处理它为止。

2. [命令模式 (Command)](命令.md)：将一个请求封装为一个对象，从而使你可用不同的请求、队列或日志来参数化客户端，并支持可撤销的操作。

3. [解释器模式 (Interpreter)](解释器.md)：给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。

4. [迭代器模式 (Iterator)](迭代器.md)：提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。

5. [中介者模式 (Mediator)](中介者.md)：用一个中介对象来封装一系列的对象交互，使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。

6. [备忘录模式 (Memento)](备忘录.md)：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便将来可以恢复该对象。

7. [观察者模式 (Observer)](观察者.md)：定义对象间的一种一对多依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。

8. [状态模式 (State)](状态.md)：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎改变了它的类。

9. [策略模式 (Strategy)](策略.md)：定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换，本模式使得算法可独立于使用它的客户而变化。

10. [模板方法模式 (Template Method)](模板方法.md)：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。

11. [访问者模式 (Visitor)](访问者.md)：表示一个作用于某对象结构中的各元素的操作，它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。