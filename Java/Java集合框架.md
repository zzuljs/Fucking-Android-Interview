# 1 HashMap 基本原理  

HashMap 通过“哈希散列 + 数组 + 链表 + 红黑树”实现键值对的存储和查找  

```java
// HashMap 的核心数据结构
transient Node<K,V>[] table; // 数组 + 链表/红黑树的组合
```

Node<K, V> 是哈希表中的一个元素，包含：键、值、hash 值、next指针  

从 Java 8 开始，当链表长度大于一定阈值（默认为 8），会转化为红黑树以提升查询效率  

红黑树（Red-Black Tree）是一种自平衡的二叉搜索树（BST），它通过在插入和删除时对节点进行颜色标记和旋转操作，保持树的高度平衡，从而保证最坏情况下的查询效率为 O(log n)  

# 2 ConcurrentHashMap如何实现线程安全  

ConcurrentHashMap 通过 分段锁机制（JDK7） 或 CAS+锁分离（JDK8） 来实现线程安全，避免全表加锁带来的性能瓶颈    

```java
transient volatile Node<K,V>[] table;
```

## 读操作 

```java
public V get(Object key) {
    Node<K,V>[] tab; Node<K,V> e; int n; K k;
    // 通过 hash 定位桶，然后链表遍历查找
}
```

table 是 volatile 修饰的，保证可见性

多线程读取不加锁，因为数据结构不会被破坏

查找通过链表或红黑树，效率高


## 写操作:CAS + synchronized  

写入流程（简化版）：
计算 hash 值

判断 table 是否初始化，懒加载

定位数组槽位（桶）

使用 CAS 尝试插入第一个节点（空桶）

如果 CAS 失败，说明已有元素：

使用 synchronized 锁定该桶的头节点

遍历链表/红黑树插入或替换节点

若链表长度超过阈值（8），转为红黑树

若当前负载超标，触发 扩容


# 3 LinkedList与ArrayList的区别  

底层实现对比  

| 特性    | `ArrayList`     | `LinkedList` |
| ----- | --------------- | ------------ |
| 底层结构  | 动态数组（Object\[]） | 双向链表（双链表）    |
| 内存连续性 | 连续内存            | 非连续，每个节点独立   |


操作方法对比  

| 操作                    | `ArrayList` 时间复杂度 | `LinkedList` 时间复杂度 | 原因说明              |
| --------------------- | ----------------- | ------------------ | ----------------- |
| `get(int index)`      | O(1)              | O(n)               | 数组支持随机访问，链表要遍历    |
| `add(E e)` (尾部)       | O(1) 均摊           | O(1)               | 都在尾部追加            |
| `add(int index, E e)` | O(n)              | O(n)               | 都需定位元素位置，链表额外操作指针 |
| `remove(int index)`   | O(n)              | O(n)               | 定位位置 + 移动/断开指针    |
| 内存使用                  | 较少                | 较多                 | 链表每个节点需额外两个指针     |


使用场景  

| 需求场景               | 建议使用           | 理由          |
| ------------------ | -------------- | ----------- |
| 频繁访问元素（如 for 循环遍历） | ✅ `ArrayList`  | 支持快速随机访问    |
| 插入、删除操作频繁（尤其中间位置）  | ✅ `LinkedList` | 不需整体元素移动    |
| 内存敏感场景             | ✅ `ArrayList`  | 占用更少内存      |
| 实现队列/栈             | ✅ `LinkedList` | 更适合头插、尾删等操作 |
